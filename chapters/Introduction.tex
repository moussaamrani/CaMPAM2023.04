\section{Introduction}
\label{sec:Introduction}

Today's software systems, and systems in general, have reached a complexity which makes it nearly impossible to comprehend the entire system at once.
This is especially the case when, e.g., in the development of cyber-physical systems, developers from multiple domains are working together on the same system.
Modern model-driven development tools therefore need to provide abstractions of the modeled system.
In order to reduce the accidental complexity for a specific task, tools should present only the necessary part of the system in the most appropriate way.
An established solution for this are \emph{views}, which show a part of the system from a certain \emph{viewpoint} \autocite{atkinson_orthographic_2010}.
In a model-driven context, views are usually also models and therefore adhere to a \metamodel.
The \metamodel of a view is called a \emph{\viewtype} \autocite{goldschmidt_towards_2012} and describes which information is shown in a view and how it is presented.

While for established, general purpose (modeling) languages (e.g., Java, UML, SysML, Simulink), evolution is typically infrequent, for domain specific languages developed in-house in industrial settings this may not be the case: there, evolution will typically be more frequent as languages are developed and adapted over time, with increasing insight or to reflect increasing use and capabilities in such in-house DSLs. Since languages evolve, so do their \metamodels. This is well-known from the literature and industrial practice \cite{durisic_evolution_2014}. Yet as a result of this, \viewtypes depending on such languages and \metamodels need to evolve along with the evolution of the underlying \metamodels. Regardless of the frequency of \metamodel evolution, any view-based framework should support such evolution and hence meta-model-view-type co-evolution, in order for the various views to stay consistent with the models. 

In this paper, we focus on such \metamodel-\viewtype co-evolution which as far as we know has not been considered in the literature before---unlike co-evolution of concrete models (or views) with changes in their \metamodel (or \viewtype). %\LC{You are probably right. I was thinking about \metamodel-model co-evolution, and viewtypes as metamodels}\LK{Is co-evolution of view types and views researched? I would have thought it would be enough to change the view type and re-generate the views with the new view type.}
We focus our attention on \metamodel-\viewtype co-evolution where first the \metamodel is changed, then the \viewtype, since the latter is conceptually typically a \metamodel derived from the former. % (via operations such as filtering, selection, and others). \LK{Should we still mentioned concrete operators? I'm not sure we're actually using them anymore.}
We do not explicitly consider scenarios where a \viewtype to be evolved depends on multiple \metamodels, although our approach remains applicable by merging the required \metamodels into one. %as multiple \metamodels can be integrated into one. \LK{Suggestion: ``[...] although our approach remains applicable by merging the required \metamodels into one.'', since merging multiple \metamodels comes with certain drawbacks.}
%That is, we do not consider evolution scenarios where first the \viewtype is changed and then the underlying \metamodel should be co-evolved; we consider that while conceptually evolution may initially be considered at the \viewtype level, it makes more sense to then consider what needs to change at the \metamodel level to accommodate this, before considering what changes this might trigger on the \viewtype level. 

We offer an approach for co-evolving \viewtypes based on \metamodel changes, in which the so-called \textit{methodologist}~\Textcite{atkinson_orthographic_2010}, i.e.~the language engineer responsible for the \viewtype, is supported by offering them recommendations and considerations to take into account, given specific \metamodel changes and the \viewtype changes that these might require. We emphasize that our approach is a manual one---given the breadth of potential \metamodel changes and \viewtypes-\metamodel dependencies (directly, or through view generation transformations), it is impossible to determine without human input what if any changes to make to a \viewtype.
Our approach is first a generic one, offering domain-independent suggestions for the most important \metamodel evolution steps, but we also describe and show how it can be specialized with domain-specific suggestions for specific application domains or implementation language domains, exemplifying this for \LC{TODO once domains settled}.

Our work offers the following contributions:
\begin{itemize}
    \item An approach to offer domain-independent suggestions for the most important \metamodel evolution steps.
    \item A means of extending this approach to specific application domains, as well as implementation language domains.
    \item The application of the former to the domains of \LC{TODO: once domains settled}, leading to a concrete, partially generic and partially domain-specific lists of suggestions per \metamodel evolution step.
\end{itemize}
\LC{TODO: overview of approach and contributions}

\TW{Adapt to changed paper structure} The rest of this paper is organized as follows. In Section~\ref{sec:Background} we cover background on view-based development, view generation, and \metamodel evolution. Section~\ref{sec:Example} considers an example scenario for our approach. Section~\ref{sec:Suggestion} discusses what suggestions for evolution in our approach are, while Section~\ref{sec:Approach} presents our overall approach. %, which is formalized in Section~\ref{sec:Formalization}.
% In Section~\ref{sec:Evaluation} we evaluate our approach.\LC{Not sure we'll get there, leave out?} 
Finally, Sections~\ref{sec:RW} and Sections~\ref{sec:Conclusion} cover related work and concluding remarks.