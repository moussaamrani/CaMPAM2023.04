\section{Introduction}
\label{sec:Introduction}

Today's software systems, and systems in general, have reached a complexity which makes it nearly impossible to comprehend the entire system at once.
This is especially the case when, e.g., in the development of cyber-physical systems, developers from multiple domains are working together on the same system.
Modern model-driven development tools therefore need to provide abstractions of the modeled system.
In order to reduce the accidental complexity for a specific task, tools should present only the necessary part of the system in the most appropriate way.
An established solution for this are \emph{views}, which show a part of the system from a certain \emph{viewpoint} \autocite{atkinson_orthographic_2010}.
In a model-driven context, views are usually also models and therefore adhere to a \metamodel.
The \metamodel of a view is called a \viewtype \autocite{goldschmidt_towards_2012} and describes which information is shown in a view and how it is presented.

While for established, general purpose (modeling) languages (e.g., Java, UML, SysML, Simulink), evolution is typically infrequent, for domain specific languages developed in-house in industrial settings this may not be the case: there, evolution will typically be more frequent as languages are developed and adapted over time, with increasing insight or to reflect increasing use and capabilities in such in-house DSLs. Since languages evolve, so do their \metamodels. This is well-known from the literature and industrial practice \cite{durisic_evolution_2014}. Yet as a result of this, \viewtypes depending on such languages and \metamodels need to evolve along with the evolution of the underlying \metamodels. Regardless of the frequency of \metamodel evolution, any view-based framework should support such evolution and hence meta-model-view-type co-evolution, in order for the various views to stay consistent with the models. 

In this paper, we focus on such \metamodel-\viewtype co-evolution---in that direction, and at that meta-level; that is, we do not consider co-evolution of the concrete models and views instantiating the \metamodel or \viewtype. That is, we do not consider evolution scenarios where first the \viewtype is changed and then the underlying \metamodel should be co-evolved; we consider that while conceptually evolution may initially be considered at the \viewtype level, it makes more sense to then consider what needs to change at the \metamodel level to accommodate this, before considering what changes this might trigger on the \viewtype level. We also do not explicitly consider scenarios where a \viewtype to be evolved depends on multiple \metamodels. (Since multiple \metamodels can be integrated into one, this is not a severe limitation either.)

\begin{itemize}
    \item motivating example (in-house developed DSLs, domain-specific \metamodel extension, BPMN4CPS)
    \item overview of approach and contributions
\end{itemize}

\textbf{Limitations:}
\begin{itemize}
    \item we do not support \metamodel \metamodel co-evolution [weâ€™re looking at view-based only, not necessarily V-SUM, so MM-MM co-evolution not a concern]
    \item we do not support \metamodel model co-evolution
    \item \st{we only support co-evolution from the metamodel to the viewtype (which is actually not a limitation, since conceptually one can still start at the viewtype)}
    \item \st{we only support one metamodel as the source of a viewtype}
\end{itemize}

\MA{Find a running example to illustrate (i) some of the operators; (ii) the formal definitions in \S \ref{sec:Formalization}; }