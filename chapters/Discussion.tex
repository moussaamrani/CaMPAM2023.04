\section{Discussion}
\label{sec:Discussion}

The approach sketched in this paper aims at recommending possible changes 
for realigning \viewtypes when changes are observed or detected on a 
\metamodel. Our approach assumes that \metamodel changes are expressed
as a set, or a sequence of change \textsf{Operator}s: we therefore build
on existing approaches for detecting and classifying evolution changes
(cf. \cite{herrmannsdoerfer_extensive_2011,khelladi_detecting_2015} and  \cref{sec:MetaModelEvolution}).

Our work fits into the general topic of \metamodel/\metamodel co-evolution,
but with specific restrictions. First, although \viewtypes are structurally 
plain \metamodels, they serve the specific purpose of showing the system from a 
certain perspective.
As such, \viewtypes can be seen as abstractions of the underlying \metamodel{}(s):
information from the original \metamodel{}(s) may be lost (i.e. irrelevant for 
the view), other may be presented differently (simplified, aggregated such as 
\textsf{nbStates} in \cref{fig:VT:VMM}, etc.). Therefore, our
\textsf{Suggestion}s closely follow what an \textsf{Operator} describes on
the evolved \metamodel, but translates this evolution into \emph{all} impacted
elements of \emph{all} \viewtypes, as described in \cref{tab:suggestions}.
This is a key feature of our approach, and this is made possible by two factors.
First, the traceability \textsf{Relation} (cf. \cref{fig:Relation}), which traces
the impacted \viewtype elements by a change. And second, \viewtypes need to be kept
consistent with the underlying \metamodel(s), in the sense that they only refer
to (\metamodel) elements that actually exist. 
Extending our approach to plain \metamodels, instead of \viewtypes, may partially
work depending on the nature of the co-evolved \metamodels and how
both \metamodels are related, but they are certainly not directly generalisable.

Second, in our view on (projective) view-based development, views are generated
from models using View Generation Transformations (VGTs). As we have pointed out in our
example, a natural extension point, which may sometimes be equally important,
is to \emph{also} provide \textsf{Suggestion}s at the VGT level to help the
methodologist correct how information is represented (from models to the views),
but also how edits in views may translate back into the various models specifying
the system. We briefly sketched in our example how simple cases for the first 
direction may be addressed. The reverse direction is way more complicated, and 
requires further research. 
It will likely impose to refine our conceptual model to integrate information
on VGTs, and \textsf{Suggestion}s would highly depend on how precise 
\textsf{Relation}s are computed. 

Third, evolving a \metamodel and its associated \viewtypes naturally requires to
co-evolve the corresponding 
% underlying\LC{'underlying' is the wronge word imo; it's instances, I would not say those are underlying, rather, the meta-level underlies the instance-level, not the other way around. 'instantiating'?}\LK{I think this is ``underlying'' in the sense that views are generated from underlying models (as in \emph{single underlying model}).}\HM{changed with corresponding} 
model(s) and view(s). We would simply reuse existing 
techniques and tools for \metamodel/model co-evolution (as discussed in \cref{sec:RW}),
from which, in our approach, views would be automatically generated using VGTs.

%\textbf{Limitations:} \textbf{\textsl{All these items are now coverdd in the discussion above}}
%\begin{itemize}
%    \item we do not support metamodel/metamodel co-evolution: weâ€™re looking 
%		at view-based only, not necessarily V-SUM, so MM-MM co-evolution not a concern
%    \item we do not support metamodel/model co-evolution
%    \item we only support co-evolution from the metamodel to the viewtype (which is actually not a limitation, since conceptually one can still start at the viewtype)
%    \item we only support one metamodel as the source of a viewtype
%\end{itemize}