\section{Approach} 
\label{sec:Approach}

For the \metamodel-\viewtype co-evolution we identified 34 operators from the change catalogue proposed by \cite{herrmannsdoerfer_extensive_2011}, which contains 27 \textit{primitive} and 34 \textit{complex} operators. Our work addresses all primitive and 7 complex operators. We choose the complex operators based on the work of \cite{khelladi_detecting_2015} who claims that these changes constitute 72\% of all complex changes during the evolution of GMF. \Cref{tab:suggestions} summarises the operators, their types, corresponding suggestions, and severity of applying these operators. We divided the chosen operators into three severity categories: major (M), minor (N), and ignore (I).
\MA{IMO, it's not the severity that "divides" the operators. 
The severity "characterises", or "classifies". However, I suggest to 
use some kind of classification of operators to avoid the long list.
cf. Herrmannsdoerfer et al. among others.}
When applied to a \metamodel, the operators in the latter category have no effect on the corresponding \viewtypes. The operators that can break the relationship between the evolving \metamodel and the corresponding \viewtypes are categorised as major. We classify the rest of the operators as minor since they are not breaking and can enrich the \viewtypes with additional information.

Among the primitive operations the creation of various entities are of minor severity as they do not influence the existing relation between the \metamodel and corresponding \viewtypes. For the creation of package, class, data type, and enumeration, we only notify the modeller about the addition of these entities. 
According to the \metamodeling formalism proposed by \cite{herrmannsdoerfer_extensive_2011}, attributes and references, and literals, have composition relation with resp. classes and enumerations. Therefore, in the event of the creation of these entities, we first identify the \viewtypes that reference the corresponding container (i.e., class or enumeration) and suggest the addition of the new entities for these \viewtypes.

The deletion of a package is possible iff it is empty and therefore, this operation can be safely ignored. Deleting class, feature, data type, and enumeration can have major consequence if these entities are referred from one or more related \viewtypes as the partial representation relation with the corresponding \metamodel no longer holds. Therefore, the suggestion is to remove these entities also from the \viewtypes.

The \textit{Make Class Abstract} and \textit{Drop Class Abstract} are about making an existing class abstract and vice versa. As these operations only changes the abstraction without modifying the list of features, they can be ignored in the context of \viewtype co-evolution. 

The deletion of an opposite reference removes access to the referenced entity from the referencing one. The corresponding suggestion is to remove the references also from the \viewtype. \textit{Merge Literal} removes a literal and replaces its occurrence with another one. Therefore, applying this operations triggers the suggestion to replace the deleted literal with an existing one in the \viewtype. \textit{Rename} and \textit{Change Package} operators generate suggestions to do the same (i.e., renaming and changing package location) on the related \viewtypes.

The \textit{Add Super Type} and \textit{Remove Super Type} operators adds and removes inherited features from an existing class. Accordingly, the corresponding suggestion suggests the addition or removal of inherited features wherever the child class is referenced in the \viewtype. Although the suggestion for the former is of minor severity, the removal of features can break the \viewtype and hence, is classified as major.

The \textit{Make Attribute Identified} and \textit{Drop Attribute Identifier} operators adds or removes a constraint that ensures the uniqueness of the attribute values. The \textit{Make Reference Composite} and \textit{Drop Reference Composite} adds or removes the containment restriction for an reference. Since, these are instance level constraints, they do not influence the \viewtype and therefore, can be ignored.

\HM{Discuss \textit{Make ref opposite and drop ref opposite}}

The \textit{Move Property} operator triggers the suggestion to update the corresponding location in the \viewtype. Pushing a property down in the hierarchy removes the property from the super class and therefore, it needs to be removed from the \viewtype wherever it is referred using a reference of the super class. The \textit{Pull Up} operator can be applied iff the corresponding feature is present in all the child classes. Since the feature is still accessible via inheritance, this does not trigger any suggestion for the related \viewtypes.

Extracting super class does not influence the effective set of features and therefore, triggers a minor suggestion for replacing some occurrences of the child class reference with the parent. The \textit{Flatten Hierarchy} moves all the features from the parent to the child classes and deletes the parent class. Therefore, this triggers a major suggestion for replacing all the references of the removed super class with the appropriate child class reference. Since the effective features of the child classes remain the same before and after fattening, we offer no suggestion for the child classes. The \textit{Extract Class} operator groups a set of features into a new delegate class and replaces their occurrences with a reference to the delegate class. The \textit{Inline Class} operator is the exact opposite of \textit{Extract Class}. Both triggers a major suggestion of adapting the location of any related feature referenced in the \viewtype.

\begin{table*}[ht!]
\caption{Suggestions per change operator. The Primitive and Complex operators are denoted respectively with P and C. \MA{Give a legend for the abbreviations in "Type" and "Severity" columns. Similarly, the "TYPE" values are never explained in the text (and should be part of the legend as well).}} \label{tab:suggestions}
\centering
\begin{tabular}{|l|c|p{.33\linewidth}|p{.31\linewidth}|c|}
\hline
Operator & Type & Condition to offer suggestion & Suggestion & Severity \\ \hline \hline

Create Package &  
\multirow{4}{*}{P} & 
\multirow{4}{*}{None} &      
\multirow{4}{*}{Notify the addition of the new entities} &
\multirow{4}{*}{N} \\ \cline{1-1}
Create Class &  &    &      &             \\ \cline{1-1}
Create Data Type &  &    &      &             \\ \cline{1-1}
Create Enum &    &  &      &             \\ \hline

Create Reference & \multirow{4}{*}{P} &    
\multirow{4}{*}{\parbox{\linewidth}{Containers (i.e., package, class) to which the entity is added are referenced from the \viewtype}} &      
\multirow{4}{*}{\parbox{\linewidth}{Suggest the addition of the new entities in the \viewtype}} &
\multirow{4}{*}{N} \\ \cline{1-1}
Create Opposite Ref. &   &   &      &             \\ \cline{1-1}
Create Attribute &  &    &      &             \\ \cline{1-1}
Create Literal &    &  &      &             \\ \hline

Delete Package  & P &
None & None. & N \\ \hline

Delete Class & \multirow{4}{*}{P} & 
\multirow{4}{*}{\parbox{\linewidth}{Entity or corresponding feature referenced by \viewtype}} &
\multirow{4}{*}{Suggest the deletion of the corresponding entity} & \multirow{4}{*}{M}           \\ \cline{1-1}
Delete Feature  &     & &      &             \\ \cline{1-1}
Delete Data Type  &    &  &      &             \\ \cline{1-1}
Delete Enum  &   &   &      &             \\ \hline

Make Class Abstract  & \multirow{2}{*}{P} & \multirow{2}{*}{None}     & \multirow{2}{*}{None}     & \multirow{2}{*}{I} \\ \cline{1-1}
Drop Class Abstract  &  & &  & \\ \hline

Delete Opposite Ref.  & P &  \Viewtype refers the referencing class & Suggest referenced class and corresponding features not accessible & M            \\ \hline
Merge Literal  & P&  Merged literal referenced by \viewtype    & Suggest the replacing literal  & M            \\ \hline
Rename  & P& Old name referred in the \viewtype  &  Suggest the old name and the corresponding new name  & M \\ \hline
Change Package  & P& Corresponding entity referred in \viewtype & Suggest changing of the package & M \\ \hline
Add Super Type  & P& Child types are referred in \viewtype & Suggest addition of inherited features for all child types & N  
% (does ST has property?) yes.       
\\ \hline
Remove Super Type  & P& Features inherited from removed super type are referred in \viewtype & Suggest removal of features that were previously inherited & M 
% (super type is empty?) no.     
\\ \hline
Make Attr. Identiﬁer   & \multirow{4}{*}{P} &  \multirow{4}{*}{None}    &  \multirow{4}{*}{None}    & \multirow{4}{*}{I}            \\ \cline{1-1}
Drop Attr. Identiﬁer  & &      &      &     \\ \cline{1-1}
Make Ref. Composite  & &      &      &             \\ \cline{1-1}
Switch Ref. Composite  & &      &      &             \\ \hline
Make Ref. Opposite  & P&      &   Discuss   &             \\ \hline
Drop Ref. Opposite  & P&      &    Discuss  &             \\ \hline
Move Property  & C &  Corresponding property referred in \viewtype  & Suggest the source and destination of the moved property & M \\ \hline
Push Property   & C & Super class referred in \viewtype  & Suggest removal of features from super class & M \\ \hline
Pull Property   & C & None & None & I \\ \hline
Extract Super Class  & C & Child classes referred in \viewtype  & Suggest possible replacement of child classes with newly created super class & N  \\ \hline
Flatten Hierarchy   & C & Removed super class is referenced in \viewtype &   Suggest removal of super class and replace all of its occurrences with appropriate child class   &  M           \\ \hline
Extract Class   & C & Extracted features from the delegate class are referred in \viewtype & Suggest the moving of features to the delegate class from the original class & M \\ \hline
Inline Class   & C & Delegate class is referenced in \viewtype & Suggest moving of features from delegate class to class that referenced the delegate class & M            \\ \hline

\end{tabular}
\end{table*}