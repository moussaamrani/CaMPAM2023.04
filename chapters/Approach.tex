\section{Approach} 
\label{sec:Approach}

\LC{TODO: talk about domain-specific approach / refinements to approach, considering state charts }
\MA{The description of the MM for \textsf{Suggestion} has been lifted up on \S \ref{sec:Suggestion}. This Section should now
detail Table \ref{tab:suggestions}, and explain the \emph{choices} operated by our \textsf{Recommendation}s: \textbf{\emph{Why}}, 
when a MM element of this type is \emph{craeted}, do we suggest the \textsf{ADD}ition of ... in the \textsf{VT}? In other words,
this Section details the "content" of the \textsf{Suggestion} MM!}

As explained in Sec. \ref{sec:Suggestion:Change}, based on the how \viewtypes are affected we grouped the MM change \textsf{Operator}s into three severity categories: \textit{MAJOR}, \textit{MINOR} and \textit{IGNORE}. The following \textsf{Operator}s are categorised as \textsf{IGNORE}: \textit{Delete Package}, \textit{Make/Drop Class Abstract}, \textit{Make/Drop Attribute Identifier}, \textit{Make/Switch Reference Composite}, \textit{Make/Switch Reference Opposite} and \textit{Pull Property}. These operators are excluded from Table~\ref{tab:suggestions}, which lists the chosen MM change \textsf{Operator}s and corresponding \textsf{Recommendation}s, since they don't result into any \textsf{Recommendation}s.



% The following \textsf{Operator}s have severity \textsf{IGNORE}, and are 
% therefore not included in Table~\ref{tab:suggestions} since they do result
% in no \textsf{Recommendation}s: \textsf{Make/Drop Class Abstract}, 
% \textsf{Make/Drop Attribute Identifier}, \textsf{Make/Switch Reference Composite},
% and \textsf{Pull Property}.




Among the primitive operations the creation of various entities are of minor severity as they do not influence the existing relation between the \metamodel and corresponding \viewtypes. For the creation of package, class, data type, and enumeration, we only notify the modeller about the addition of these entities. 
According to the \metamodeling formalism proposed by \cite{herrmannsdoerfer_extensive_2011}, attributes and references, and literals, have composition relation with resp. classes and enumerations. Therefore, in the event of the creation of these entities, we first identify the \viewtypes that reference the corresponding container (i.e., class or enumeration) and suggest the addition of the new entities for these \viewtypes.

The deletion of a package is possible iff it is empty and therefore, this operation can be safely ignored. Deleting class, feature, data type, and enumeration can have major consequence if these entities are referred from one or more related \viewtypes as the partial representation relation with the corresponding \metamodel no longer holds. Therefore, the suggestion is to remove these entities also from the \viewtypes.

The \textit{Make Class Abstract} and \textit{Drop Class Abstract} are about making an existing class abstract and vice versa. As these operations only changes the abstraction without modifying the list of features, they can be ignored in the context of \viewtype co-evolution. 

The deletion of an opposite reference removes access to the referenced entity from the referencing one. The corresponding suggestion is to remove the references also from the \viewtype. \textit{Merge Literal} removes a literal and replaces its occurrence with another one. Therefore, applying this operations triggers the suggestion to replace the deleted literal with an existing one in the \viewtype. \textit{Rename} and \textit{Change Package} operators generate suggestions to do the same (i.e., renaming and changing package location) on the related \viewtypes.

The \textit{Add Super Type} and \textit{Remove Super Type} operators adds and removes inherited features from an existing class. Accordingly, the corresponding suggestion suggests the addition or removal of inherited features wherever the child class is referenced in the \viewtype. Although the suggestion for the former is of minor severity, the removal of features can break the \viewtype and hence, is classified as major.

The \textit{Make Attribute Identified} and \textit{Drop Attribute Identifier} operators adds or removes a constraint that ensures the uniqueness of the attribute values. The \textit{Make Reference Composite} and \textit{Drop Reference Composite} adds or removes the containment restriction for an reference. Since, these are instance level constraints, they do not influence the \viewtype and therefore, can be ignored.

\HM{Discuss \textit{Make ref opposite and drop ref opposite}} \MA{I have some arguments to say that we could ignore these in a first attempt, because "opposite"s may always be computed, assuming you have a "decent" meta-metamodel API (as EMF/Ecore provides, among others).}\LC{I agree.}

The \textit{Move Property} operator triggers the suggestion to update the corresponding location in the \viewtype. Pushing a property down in the hierarchy removes the property from the super class and therefore, it needs to be removed from the \viewtype wherever it is referred using a reference of the super class. The \textit{Pull Up} operator can be applied iff the corresponding feature is present in all the child classes. Since the feature is still accessible via inheritance, this does not trigger any suggestion for the related \viewtypes.

Extracting super class does not influence the effective set of features and therefore, triggers a minor suggestion for replacing some occurrences of the child class reference with the parent. The \textit{Flatten Hierarchy} moves all the features from the parent to the child classes and deletes the parent class. Therefore, this triggers a major suggestion for replacing all the references of the removed super class with the appropriate child class reference. Since the effective features of the child classes remain the same before and after fattening, we offer no suggestion for the child classes. The \textit{Extract Class} operator groups a set of features into a new delegate class and replaces their occurrences with a reference to the delegate class. The \textit{Inline Class} operator is the exact opposite of \textit{Extract Class}. Both triggers a major suggestion of adapting the location of any related feature referenced in the \viewtype.

\begin{table*}[ht!]
\caption{Suggestions per change operator. The Primitive and Complex operators are denoted respectively with P and C. \MA{Give a legend for the abbreviations in "Type" and "Severity" columns. Similarly, the "TYPE" values are never explained in the text (and should be part of the legend as well).}\HM{group all none suggestions}} \label{tab:suggestions}
\centering
\begin{tabular}{|l|c|p{.33\linewidth}|p{.31\linewidth}|c|}
\hline
Operator & Type & Condition to offer suggestion & Suggestion & Severity \\ \hline \hline

Create Package $(p)$&  
\multirow{8}{*}{P} & 
\multirow{8}{*}{\parbox{\linewidth}{The container of $x$ is referred in the \viewtype, where $x \in \{p, c, dt, e, r, or, a, l\}$}} &      
\multirow{8}{*}{Suggest $ADD(x)$ in the \viewtypes} &
\multirow{8}{*}{N} \\ \cline{1-1}
Create Class $(c)$&  &    &      &             \\ \cline{1-1}
Create Data Type $(dt)$&  &    &      &             \\ \cline{1-1}
Create Enum $(e)$&    &  &      &             \\ \cline{1-1}

Create Reference ($r$)& &  &      &             \\ \cline{1-1}
% \multirow{4}{*}{P} &    
% \multirow{4}{*}{\parbox{\linewidth}{Containers (i.e., package, class) to which the entity is added are referenced from the \viewtype}} &      
% \multirow{4}{*}{\parbox{\linewidth}{Suggest the addition of the new entities in the \viewtype}} &
% \multirow{4}{*}{N} \\ \cline{1-1}
Create Opposite Ref. ($or$)&   &   &      &             \\ \cline{1-1}
Create Attribute ($a$)&  &    &      &             \\ \cline{1-1}
Create Literal ($l$)&    &  &      &             \\ \hline

% Delete Package  & P &
% None & None. & N \\ \hline

Delete Class ($c$)& \multirow{4}{*}{P} & 
\multirow{4}{*}{\parbox{\linewidth}{$x$ is referenced in the \viewtype, where $x \in \{c, f, dt, e\}$}} &
\multirow{4}{*}{Suggest $DEL(x)$ from \viewtype} & \multirow{4}{*}{M}           \\ \cline{1-1}
Delete Feature ($f$) &     & &      &             \\ \cline{1-1}
Delete Data Type ($dt$) &    &  &      &             \\ \cline{1-1}
Delete Enum ($e$) &   &   &      &             \\ \hline

%Make Class Abstract  & \multirow{2}{*}{P} & \multirow{2}{*}{None}     & \multirow{2}{*}{None}     & \multirow{2}{*}{I} \\ \cline{1-1}
%Drop Class Abstract  &  & &  & \\ \hline

Delete Opposite Ref. ($or$) & P &  \Viewtype refers the referencing class & Suggest referenced class and corresponding features not accessible & M            \\ \hline
Merge Literal  ($l$)& P&  $l$ is referenced in \viewtype    & Suggest the $UP$dating $l$ with $l^\prime$, where $l$ and $l^\prime$ are contained in the same \textit{Enum} & M            \\ \hline
Rename  & P& Old name $s$ is referred in the \viewtype  &  Suggest $UP$dating $s$ with $s^\prime$ where $s^\prime$ is the current name & M \\ \hline
Change Package ($p$) & P& $x$ is referred in \viewtype, where $x\in\{p, t, dt, e, c\}$ and $x$ was contained in $p$ & Suggest $MOVE$ of $x$ from $p$ to $p^\prime$, where $p^\prime$ is the current package & M \\ \hline
Add Super Type ($t$) & P& $t_c$ is referred in \viewtype, where $t_c$ is a child type of $t$ & Suggest $ADD(f^*)$, where $f^*$ is the set of features contained in $t$ & N  \\ \hline
Remove Super Type ($t$) & P& $t_c$ is referred in \viewtype, where $t_c$ is a child type of $t$ & Suggest $DEL(f^*)$, where $f^*$ is the set of features contained in $t$ & M \\ \hline
%Make Attr. Identiﬁer   & \multirow{4}{*}{P} &  \multirow{4}{*}{None}    &  \multirow{4}{*}{None}    & \multirow{4}{*}{I}            \\ \cline{1-1}
%Drop Attr. Identiﬁer  & &      &      &     \\ \cline{1-1}
%Make Ref. Composite  & &      &      &             \\ \cline{1-1}
%Switch Ref. Composite  & &      &      &             \\ \hline
% Make Ref. Opposite  & P&  None\LC{Remove this and next line, see arguments Moussa in running text}    &   None   &             \\ \hline
% Drop Ref. Opposite  & P&   None   &    None  &             \\ \hline
Move feature ($f$) & C &  $f$ is referred in \viewtype  & Suggest $MOVE$ $f$ from $c_s$ to $c_d$, where $c_s$ and $c_d$ are previous and current container classes& M \\ \hline
Push feature ($f$)  & C & $f$ is referred in \viewtype using a reference of $c_s$, where $c_s$ is a super class from which $f$ was pushed to all its child classes $c_d$& Suggest $DEL(f)$ or $MOVE$ $f$ from $c_s$ to $c^\prime$, where $c^\prime\in c_d$   & M \\ \hline
%Pull Property   & C & None & None & I \\ \hline
Extract Super Class  & C & Child classes referred in \viewtype  & Suggest possible replacement of child classes with newly created super class & N  \\ \hline
Flatten Hierarchy   & C & Removed super class is referenced in \viewtype &   Suggest removal of super class and replace all of its occurrences with appropriate child class   &  M           \\ \hline
Extract Class   & C & Extracted features from the delegate class are referred in \viewtype & Suggest the moving of features to the delegate class from the original class & M \\ \hline
Inline Class   & C & Delegate class is referenced in \viewtype & Suggest moving of features from delegate class to class that referenced the delegate class & M            \\ \hline

\end{tabular}
\end{table*}